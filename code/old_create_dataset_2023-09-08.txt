@@ -1,462 +1,463 @@
*
AUTHOR   : KTW
PROJECT  : ISP Utilization Analysis
PURPOSE  : Gather, Process datasets from analytic subset dir, Create final analysis dataset and mini dataset
VERSION  : 2023-06-06
           - updated 5/30 due to issues in the hcpf file and to get Sept 2022 since it's available now (cs email re: hcpf)
           - updated 06/01-02 bc ana.long & ana.demo were missing months
           - updated 6/5 to combine bh cat variables into 1 bh cat var
           - updated 6/6 to check on the BH's by adding a total var and seeing
                if any of them are wrong as I'm still getting Hessian errors
VERSION  : 2023-09-08
            - 09-08 manually renamed data.analysis as data.analysis_prev, created minimized length data.utilization look for #UPDATE[09-08-2023] approx row 948
            - 06-06 to check on the BH's: added total var maybe some are wrong as I'm still getting Hessian errors
            - 06-05 to combine bh cat variables into 1 bh cat var
            - 06-02 bc ana.long & ana.demo were missing months
            - 05-30 due to issues in the hcpf file and to get Sept 2022 since it's available now (cs email re: hcpf)

DEPENDS  : -ana subset folder, config file, 
           -%include helper file in code/util_dataset_prep/incl_extract_check_fy19210.sas
           -other macro code referenced is stored in the util_00_config.sas file
OUTPUT
SECTION1 : data.analysis
SECTION2 : data.analysis_allcols
SECTION3 : data.mini_ds (test set with only 500000 records) ;

%INCLUDE "S:/FHPC/DATA/HCPF_DATA_files_SECURE/Kim/isp/isp_utilization/code/util_00_config.sas"; 
%INCLUDE "S:/FHPC/DATA/HCPF_DATA_files_SECURE/Kim/isp/isp_utilization/code/config.sas"; 

* 
[RAW.time_dim] ==============================================================================
Import a .csv file I made with months, FY, FY quarters, and the linearized time var
===========================================================================================;
PROC IMPORT FILE="&util./data/_raw/fy_q_dts_dim.csv"
    OUT = raw.time_dim
    DBMS=csv
    REPLACE;
run; 

* 
[QRYLONG_00] ==============================================================================
1. SUBSET qry_longitudinal to timeframe (months le/ge) AND:
   -- budget_groups
   -- sex not Unknown
   -- pcmp_loc_id not missing
   -- managedCare not 0
   NB: Can't subset to records with an RAE yet since that would exclude FY16-18 records
2. Create dt_qrtr: the first month of the quarter that the record was in
===========================================================================================;
DATA   raw.qrylong_00 (DROP=managedCare);
LENGTH mcaid_id $11; 
SET    ana.qry_longitudinal (WHERE=(month ge '01Jul2016'd AND month le '30Sep2022'd 
                                    AND BUDGET_GROUP not in (16,17,18,19,20,21,22,23,24,25,26,27,-1,)
                                    AND managedCare = 0
                                    AND pcmp_loc_id ne ' ') 
                             DROP = FED_POV: DISBLD_IND aid_cd: title19: SPLM_SCRTY_INCM_IND
                                    SSI_: SS: dual eligGrp fost_aid_cd) ;  
format dt_qrtr date9.; 
dt_qrtr = intnx('quarter', month ,0,'b'); 
FY      = year(intnx('year.7', month, 0, 'BEGINNING'));
PCMP2   = input(pcmp_loc_id, best12.); DROP pcmp_loc_id; RENAME pcmp2 = pcmp_loc_id; 
RUN;  *6/07 75691244;

* 
INT.PCMP_DIM ==============================================================================
DESCR: Extract unique pcmp_loc_ids and their dimensions, stored as a reference table, that:
1. Reduces qrylong for interim processing steps,
2. Reduces pcmp_loc_ids to unique records for faster calculations:
    2a: convert pcmp_loc_id to numeric
3. Create binary covariate FQHC from pcmp_loc_type_cd values (rather than formats) 
===========================================================================================;
DATA pcmp_type_qrylong ; 
SET  raw.qrylong_00   (KEEP = pcmp_loc_id  pcmp_loc_type_cd pcmp_loc_type_cd 
                       WHERE= (pcmp_loc_id ne .));
num_pcmp_type = input(pcmp_loc_type_cd, 7.);
RUN ; 

PROC SORT DATA = pcmp_type_qrylong NODUPKEY ; BY _ALL_ ; RUN ; 

DATA int.pcmp_dim;
SET  pcmp_type_qrylong;
IF pcmp_loc_type_cd in (32 45 61 62) then fqhc = 1 ; else fqhc = 0 ;
RUN; *1462;

* 
[RAW.QRYLONG_01]======================================================================
Joins ana.qry_demographics, raw.age_dim, and rae_dim
Purpose:
1. Get rae_person_new on enr_county (from qrylong)
2. Demographic vars: dob(for calculating age/subsetting members 0-64), gender, race
3. Subset sex M, F
4. Get dob to calculate ages (subsetting var)
===========================================================================================;
PROC SQL; 
CREATE TABLE raw.qrylong_01 AS
SELECT a.mcaid_id
     , a.pcmp_loc_id
     , a.month
     , a.enr_cnty
     , a.budget_group
     , a.dt_qrtr 
     , a.FY
     , b.dob
     , b.gender as sex
     , b.race
     , c.rae_id as rae_person_new
     , d.time
     , d.fy_qrtr
FROM raw.qrylong_00             AS A 
LEFT JOIN ana.qry_demographics  AS B ON a.mcaid_id = b.mcaid_id 
LEFT JOIN int.rae_dim           AS C ON a.enr_cnty = c.hcpf_county_code_c
LEFT JOIN raw.time_dim          AS D on a.dt_qrtr  = d.month
WHERE  pcmp_loc_id ne .
AND    SEX IN ('F','M');
QUIT;   *06-07 75690836 : 10 cols;

PROC FREQ Data=raw.qrylong_01;
table time*FY;
where fy in (2019, 2020, 2021, 2022);
RUN;

* 
RAW.AGE_DIM ==============================================================================
Extract dob to get age as of the 2nd month in each quarter
1. Used in subsetting dataset
2. Used to create age_cat
Will have to inner join these variables on qrylong eventually unless you subset it by this earlier
===========================================================================================;
* Get distinct mcaid_id and dob;
PROC SQL;
CREATE TABLE raw.age_dim_00 AS 
SELECT distinct(mcaid_id) as mcaid_id
     , dob
     , time
FROM raw.qrylong_01
WHERE FY in (2019, 2020, 2021, 2022)
AND   rae_person_new ne .;
QUIT; * 6/7 when I run with time, I get 15719759 obs 2 col (when I run without time, I get about 100k more...); 

* Find / List all 13 2nd month of quarter values; 
PROC SQL NOPRINT;
SELECT month INTO :qm2 separated by ' '
FROM  raw.time_dim
WHERE month_qrtr = 2;
QUIT; 

%PUT &qm2;

* I could not for the life of me find a way to do this from the macro values and had to get moving
but I'm sure there's a better way to do this? 
Need age at month 2 of each quarter ;
%LET m2q1 = 01Aug2019; %LET m2q2 = 01Nov2019;  %LET m2q3 = 01Feb2020; %LET m2q4 = 01May2020;
%LET m2q5 = 01Aug2020; %LET m2q6 = 01Nov2020;  %LET m2q7 = 01Feb2021; %LET m2q8 = 01May2021;
%LET m2q9 = 01Aug2021; %LET m2q10 = 01Nov2021; %LET m2q11 = 01Feb2022; %LET m2q12 = 01May2022;
%LET m2q13 = 01Aug2022;
 
DATA raw.age_dim;
SET  raw.age_dim_00;
IF time = 1 then do;  age = floor((intck('month', dob, "&m2q1"d)-(day("&m2q1"d)   < min(day(dob), day(intnx('month', "&m2q1"d, 1) -1))))  /12); END;
IF time = 2 then do;  age = floor((intck('month', dob, "&m2q2"d)-(day("&m2q2"d)   < min(day(dob), day(intnx('month', "&m2q2"d, 1) -1))))  /12); END;
IF time = 3 then do;  age = floor((intck('month', dob, "&m2q3"d)-(day("&m2q3"d)   < min(day(dob), day(intnx('month', "&m2q3"d, 1) -1))))  /12); END;
IF time = 4 then do;  age = floor((intck('month', dob, "&m2q4"d)-(day("&m2q4"d)   < min(day(dob), day(intnx('month', "&m2q4"d, 1) -1))))  /12); END;
IF time = 5 then do;  age = floor((intck('month', dob, "&m2q5"d)-(day("&m2q5"d)   < min(day(dob), day(intnx('month', "&m2q5"d, 1) -1))))  /12); END;
IF time = 6 then do;  age = floor((intck('month', dob, "&m2q6"d)-(day("&m2q6"d)   < min(day(dob), day(intnx('month', "&m2q6"d, 1) -1))))  /12); END;
IF time = 7 then do;  age = floor((intck('month', dob, "&m2q7"d)-(day("&m2q7"d)   < min(day(dob), day(intnx('month', "&m2q7"d, 1) -1))))  /12); END;
IF time = 8 then do;  age = floor((intck('month', dob, "&m2q8"d)-(day("&m2q8"d)   < min(day(dob), day(intnx('month', "&m2q8"d, 1) -1))))  /12); END;
IF time = 9 then do;  age = floor((intck('month', dob, "&m2q9"d)-(day("&m2q9"d)   < min(day(dob), day(intnx('month', "&m2q9"d, 1) -1))))  /12); END;
IF time = 10 then do; age = floor((intck('month', dob, "&m2q10"d)-(day("&m2q10"d) < min(day(dob), day(intnx('month', "&m2q10"d, 1) -1)))) /12); END;
IF time = 11 then do; age = floor((intck('month', dob, "&m2q11"d)-(day("&m2q11"d) < min(day(dob), day(intnx('month', "&m2q11"d, 1) -1)))) /12); END;
IF time = 12 then do; age = floor((intck('month', dob, "&m2q12"d)-(day("&m2q12"d) < min(day(dob), day(intnx('month', "&m2q12"d, 1) -1)))) /12); END;
IF time = 13 then do; age = floor((intck('month', dob, "&m2q13"d)-(day("&m2q13"d) < min(day(dob), day(intnx('month', "&m2q13"d, 1) -1)))) /12); END;
IF age ge 65 then DELETE;
IF age lt 0  then DELETE;
RUN; *06/07 15124679;

* 
[RAW.FINAL_00] ==============================================================================
Start final list where age in range based on FY's 19-22 and rae_ not missing
===========================================================================================;
PROC SQL;
CREATE TABLE raw.final_00 AS 
SELECT a.mcaid_id
     , a.time
     , a.FY
     , a.dt_qrtr
     , a.month
     , a.pcmp_loc_id
     , a.budget_group
     , a.sex
     , a.race
     , a.rae_person_new
     , b.age
FROM raw.qrylong_01    AS A 
INNER JOIN raw.age_dim AS B ON (a.mcaid_id=b.mcaid_id AND a.time=b.time)
WHERE rae_person_new ne . 
AND FY IN (2019, 2020, 2021, 2022) ;
QUIT; *44202204 & checked freq's on util_02_checks;
* Unique mcaid_id's 06/07 = 1617613 // previous set unique mcaid_id's were 1613033 so captured about 4k more members;

* 
[RAW.QRYLONG_02] ==============================================================================
Limit ds to members id's found in age_dim
===========================================================================================;
PROC SQL;
CREATE TABLE raw.qrylong_02 AS 
SELECT mcaid_id
     , time
     , FY
     , dt_qrtr
     , month
FROM raw.qrylong_01
WHERE mcaid_id IN (SELECT mcaid_id FROM raw.final_00);
QUIT; *06/07 68741452;

* 
[RAW.FINAL_00] & [RAW.DEMO_1922] =========================================================
Subset to mcaid_id's that have an rae_assigned in FY's 19-22
===========================================================================================;
DATA raw.final_01  (KEEP = mcaid_id month dt_qrtr FY time age)
     raw.demo_1922 (KEEP = mcaid_id month dt_qrtr FY time sex race rae_person_new pcmp_loc_id budget_group);
SET  raw.final_00 ;
RUN; *06/07: both have 44202400 (ish?)
06/05 both have 44102611; 

PROC SORT DATA=raw.final_01; BY MCAID_ID FY TIME; RUN; 

*
%INCLUDE ==============================================================================
Creates table with max months' pcmp. In case of ties, takes most recent 
1. MACRO for other demo vars
2. output: int.pcmp_attr_qrtr
===========================================================================================;
%LET dv1922 = raw.demo_1922;
%INCLUDE "&util/code/util_dataset_prep/incl_extract_check_fy1922.sas";

%demo(var=budget_group,   ds=&dv1922);
%demo(var=rae_person_new, ds=&dv1922);
%demo(var=sex,            ds=&dv1922);
%demo(var=race,           ds=&dv1922);   * all have 15104152 rows; 

*macro to find instances where n_ids >13 (should be 0 // in 00_config); 
%check_ids_n13(ds=budget_group); *0;
%check_ids_n13(ds=rae_person_new);    *0;

%macro concat_id_time(ds=);
DATA &ds;
SET  &ds;
id_time_helper = CATX('_', mcaid_id, time); 
RUN; 
%mend; 

* Created helper var for joins (was taking a long time and creating rows without id, 
idk why, so did this as quick fix for now); 
%concat_id_time(ds=raw.final_01);
%concat_id_time(ds=raw.age_dim);

* 
RAW.Final_02 ==============================================================================
Joins final_01 with the calculated demo variables as well as int, int_imp
===========================================================================================;
PROC SQL ; 
CREATE TABLE raw.final_02 AS 
SELECT a.mcaid_id
     , a.dt_qrtr
     , a.month
     , a.FY
     , a.time
     , a.id_time_helper
     , a.age
     , b.budget_group
     , c.rae_person_new
     , d.pcmp_loc_id
     , d.int
     , e.fqhc
     , f.time2 as time_start_isp
     , case WHEN f.time2 ne . 
            AND  a.time >= f.time2
            THEN 1 ELSE 0 end AS int_imp
     , g.race
     , h.sex
FROM raw.final_01                    AS A
LEFT JOIN budget_group               AS B   ON A.id_time_helper = B.id_time_helper
LEFT JOIN rae_person_new             AS C   ON A.id_time_helper = C.id_time_helper
LEFT JOIN int.pcmp_attr_qrtr         AS D   ON A.id_time_helper = D.id_time_helper
LEFT JOIN int.pcmp_dim               AS E   ON D.pcmp_loc_id    = E.pcmp_loc_id   
LEFT JOIN int.isp_un_pcmp_dtstart    AS F   ON D.pcmp_loc_id    = F.pcmp_loc_id    
LEFT JOIN race                       AS G   ON A.id_time_helper = G.id_time_helper
LEFT JOIN sex                        AS H   ON A.id_time_helper = H.id_time_helper;
QUIT ;  ; 

* 
RAW.Final_03 ==============================================================================
drops some vars no longer needed, adds labels
remove duplicates
===========================================================================================;
DATA  raw.final_03;
SET   raw.final_02   (DROP=time_start_isp month id_time_helper);
LABEL pcmp_loc_id     = "pcmp_loc_ID"
      FY              = "FY 19, 20, 21, and FYQ1 of 2023"
      age             = "Age: 0-64 only"
      sex             = "Sex (M,F)"
      time            = "Linearized qrtrs, 1-13"
      int             = "ISP Participation: Time Invariant"
      budget_group    = "Budget Group (subsetting var)"
      rae_person_new  = "RAE ID"
      fqhc            = "FQHC: 0 No, 1 Yes"
      int_imp         = "ISP Participation: Time-Varying"
      ;
RUN; *44202204 ;

* 
RAW.UTIL3 ==============================================================================
Gets utilization dv's
===========================================================================================;
DATA    raw.util0; 
SET     ana.qry_monthlyutilization (WHERE=(month ge '01Jul2016'd AND month le '30Sep2022'd));
FORMAT  dt_qrtr date9.;
dt_qrtr =intnx('QTR', month, 0, 'BEGINNING'); 
FY      =year(intnx('year.7', month, 0, 'BEGINNING'));
run; *;

PROC SQL;
CREATE TABLE raw.util1 as
SELECT a.*
     , (a.pd_amt/b.index_2021_1) AS adj_pd_amount 
FROM   raw.util0    AS A
LEFT JOIN int.adj   AS b    ON a.dt_qrtr=b.date
WHERE mcaid_id IN (SELECT mcaid_id FROM raw.final_03);
quit; *58207623; 

PROC SQL;
CREATE TABLE raw.util2 AS
SELECT MCAID_ID
      , FY
      , month
      , sum(case when clmClass=4     then count else 0 end) as n_pc
      , sum(case when clmClass=3     then count else 0 end) as n_er
      , sum(case when clmClass=2     then count else 0 end) as n_rx
      , sum(case when clmClass=5     then count else 0 end) as n_ffs_bh
        
      , sum(adj_pd_amount) as adj_pd_total
      , sum(case when clmClass=4     then adj_pd_amount else 0 end) as adj_pd_pc
      , sum(case when clmClass=3     then adj_pd_amount else 0 end) as adj_pd_er
      , sum(case when clmClass=2     then adj_pd_amount else 0 end) as adj_pd_rx
      , sum(case when clmClass=5     then adj_pd_amount else 0 end) as adj_pd_ffs_bh
FROM  raw.util1
GROUP BY MCAID_ID,month;
quit; *6/7 58207623; 

%nodupkey(ds=raw.util2, out=raw.util3); *6/7 28628763, 12; 

* 
RAW.BH1 ==============================================================================
Gets BH vars
===========================================================================================;
DATA raw.bh0;
SET  ana.qry_bho_monthlyutilization; 
format dt_qrtr month2 date9.; 
dt_qrtr = intnx('quarter', month ,0,'b');
month2  = month; DROP month; RENAME month2 = month; /* make numeric, for some reason month coming in as character*/
WHERE   month ge '01Jul2016'd AND  month le '30Sep2022'd;
FY      = year(intnx('year.7', month, 0, 'BEGINNING'));
run; *4618851 observations and 8 variables;

%create_qrtr(data=raw.bh1, set=raw.bh0, var = dt_qrtr, qrtr=time);

* 
RAW.QRYLONG_04 ==============================================================================
join bh and util to qrylong to get averages (all utils - monthly, bho, telehealth) to qrylong4
    drop the demo vars because the good ones are on raw.final1
===========================================================================================;
PROC SQL; 
CREATE TABLE raw.qrylong_03 AS 
SELECT a.mcaid_id, a.month, a.dt_qrtr, a.FY, a.time
     , b.bho_n_hosp
     , b.bho_n_er
     , b.bho_n_other
     , c.n_pc
     , c.n_er
     , c.n_rx
     , c.n_ffs_bh
     , c.adj_pd_total
     , c.adj_pd_pc
     , c.adj_pd_er
     , c.adj_pd_rx
     , c.adj_pd_ffs_bh
     , d.n_tele
FROM raw.qrylong_02            AS A
LEFT JOIN raw.bh1              AS B    ON a.mcaid_id=B.mcaid_id AND a.month=B.month
LEFT JOIN raw.util3            AS C    ON a.mcaid_id=C.mcaid_id AND a.month=C.month
LEFT JOIN int.tel_fact_1922_m  AS D    ON a.mcaid_id=D.mcaid_id AND a.month=D.month;
QUIT;  *06/08 nrow 68741452 //  68079369 rows and 18 columns.;

* 
[RAW.QRYLONG_1618] ==============================================================================
[Descr]
1. [Step 1]
2. [Step 2]
===========================================================================================;
DATA raw.fy_1618_0; 
SET  raw.qrylong_03;
WHERE month lt '01Jul2019'd; 
RUN; *6/8 24127948 // 23976758; 

PROC SQL;
CREATE TABLE raw.fy_1618_1 as
SELECT mcaid_id
     , max(case when FY = 2016 then 1 else 0 end) as elig2016
     , max(case when FY = 2017 then 1 else 0 end) as elig2017
     , max(case when FY = 2018 then 1 else 0 end) as elig2018

     , avg(case when FY = 2016 then adj_pd_total else . end) as adj_pd_16pm
     , avg(case when FY = 2017 then adj_pd_total else . end) as adj_pd_17pm
     , avg(case when FY = 2018 then adj_pd_total else . end) as adj_pd_18pm

     , avg(case when FY = 2016 then bho_n_hosp  else . end) as bho_n_hosp_16pm
     , avg(case when FY = 2017 then bho_n_hosp  else . end) as bho_n_hosp_17pm 
     , avg(case when FY = 2018 then bho_n_hosp  else . end) as bho_n_hosp_18pm
     , avg(case when FY = 2016 then bho_n_er    else . end) as bho_n_er_16pm
     , avg(case when FY = 2017 then bho_n_er    else . end) as bho_n_er_17pm 
     , avg(case when FY = 2018 then bho_n_er    else . end) as bho_n_er_18pm
     , avg(case when FY = 2016 then bho_n_other else . end) as bho_n_other_16pm 
     , avg(case when FY = 2017 then bho_n_other else . end) as bho_n_other_17pm 
     , avg(case when FY = 2018 then bho_n_other else . end) as bho_n_other_18pm

FROM raw.fy_1618_0
GROUP BY mcaid_id;
QUIT; * 6/8 1138252 // 6/01 1131492;

* change adj to if elig = 0, then adj var = -1 and set bh variables to 0 where .; 
DATA raw.fy_1618_2;
SET  raw.fy_1618_1;

IF      elig2016 = 0 THEN adj_pd_16pm = -1; 
ELSE IF elig2016 = 1 AND  adj_pd_16pm = .   THEN adj_pd_16pm = 0;
ELSE adj_pd_16pm = adj_pd_16pm; 

IF      elig2017 = 0 THEN adj_pd_17pm = -1; 
ELSE IF elig2017 = 1 AND  adj_pd_17pm = .   THEN adj_pd_17pm = 0;
ELSE adj_pd_17pm = adj_pd_17pm; 

IF      elig2018 = 0 THEN adj_pd_18pm = -1; 
ELSE IF elig2018 = 1 AND  adj_pd_18pm = .   THEN adj_pd_18pm = 0;
ELSE adj_pd_18pm = adj_pd_18pm; 

ARRAY bh(*) bho_n_hosp_16pm  bho_n_hosp_17pm  bho_n_hosp_18pm
            bho_n_er_16pm    bho_n_er_17pm    bho_n_er_18pm
            bho_n_other_16pm bho_n_other_17pm bho_n_other_18pm;

DO i=1 to dim(bh);
    IF bh(i)=. THEN bh(i)=0; 
    ELSE bh(i)=bh(i);
    END;
DROP i; 

RUN; *6/8 1138252 : 16;

** GET PERCENTILES FOR ALL & TOP CODE DV's FOR MEMBERS ONLY ; 
* 1618; 
%macro pctl_1618(var,out,pctlpre);
proc univariate noprint data=raw.fy_1618_2; 
where &var gt 0; 
var &var; 
output out=&out pctlpre=&pctlpre pctlpts= 50, 75, 90, 95; 
run;
%mend; 

** SEE UTIL_02_CHECKS for code to investigate the values and check percentiles; 

%pctl_1618(var     = adj_pd_16pm,
           out     = pd16pctle,
@ -863,129 +864,198 @@
DATA data.analysis1;
SET  data.analysis0 (RENAME=(budget_group      = budget_grp_fmt_ana
                             budget_grp_no_fmt = budget_grp_num));

* assign new numeric values to 3, 5-12 / else 0 (Other);
IF         budget_grp_num = 3 THEN budget_grp_num_r = 1;
ELSE IF    budget_grp_num = 5 THEN budget_grp_num_r = 2;
ELSE IF 6<=budget_grp_num<=10 THEN budget_grp_num_r = 3;
ELSE IF    budget_grp_num =11 THEN budget_grp_num_r = 4;
ELSE IF    budget_grp_num =12 THEN budget_grp_num_r = 5;
ELSE                               budget_grp_num_r = 0;  

budget_grp_new = put(budget_grp_num_r, budget_grp_new_.);
age_cat_num = input(age_cat, best12.);

adj_pd_total_16cat_orig = adj_pd_total_16cat;
adj_pd_total_17cat_orig = adj_pd_total_17cat;
adj_pd_total_18cat_orig = adj_pd_total_18cat;

adj_pd_total_16cat = adj_pd_total_16cat + 1; 
adj_pd_total_17cat = adj_pd_total_17cat + 1; 
adj_pd_total_18cat = adj_pd_total_18cat + 1; 

LABEL budget_grp_num_r = "Budget Group Num, Recoded"
      budget_grp_new   = "Budget Group Num, Recoded plus Format"
      budget_grp_num   = "Budget Group Num"
      age_cat          = "Age Categorical"
      n_tel_pm         = "Telehealth Visits PMPQ"
      age_cat_num      = "Age Categorical Numeric Values"
      adj_pd_total_16cat_orig = "Og Scale neg value, do not use just kept to check"
      adj_pd_total_17cat_orig = "Og Scale neg value, do not use just kept to check"
      adj_pd_total_18cat_orig = "Og Scale neg value, do not use just kept to check"
      adj_pd_total_16cat = "Categorical adj ffs total 2016, Scale 0 to 6"
      adj_pd_total_17cat = "Categorical adj ffs total 2017, Scale 0 to 6"
      adj_pd_total_18cat = "Categorical adj ffs total 2018, Scale 0 to 6";
RUN;  

* [6/22/2023]
Integer values for count values so I can use negbin // mult all by 6
n_ed_pm     n_ffs_bh_pm     n_pc_pm     n_tel_pm;
 
DATA int.analysis2;
SET  int.analysis1; 
n_ed_pm_r     = round(n_ed_pm*6,     1);
n_ffs_bh_pm_r = round(n_ffs_bh_pm*6, 1);
n_pc_pm_r     = round(n_pc_pm*6,     1);
n_tel_pm_r    = round(n_tel_pm*6,    1);
LABEL n_ed_pm_r     = "Mult og val x6 to get integer for negbin"
      n_ffs_bh_pm_r = "Mult og val x6 to get integer for negbin"
      n_pc_pm_r     = "Mult og val x6 to get integer for negbin"
      n_tel_pm_r    = "Mult og val x6 to get integer for negbin";
RUN; 

* Reordered so I could see related cols together; 
DATA int.analysis3;
RETAIN mcaid_id time int int_imp season1 season2 season3 
       ind_total_cost     adj_pd_total_tc
       ind_pc_cost        adj_pd_pc_tc
       ind_rx_cost        adj_pd_rx_tc
       ind_pc_visit       n_pc_pm   n_pc_pm_r
       ind_ed_visit       n_ed_pm   n_ed_pm_r
       ind_ffs_bh_visit   n_ffs_bh_pm   n_ffs_bh_pm_r
       ind_tel_visit      n_tel_pm      n_tel_pm_r
       bh_2016  bh_hosp16   bh_er16   bh_oth16
       bh_2017  bh_hosp17   bh_er17   bh_oth17
       bh_2018  bh_hosp18   bh_er18   bh_oth18
       adj_pd_total_16cat_orig  adj_pd_total_16cat
       adj_pd_total_17cat_orig  adj_pd_total_17cat
       adj_pd_total_18cat_orig  adj_pd_total_18cat
       fqhc 
       budget_grp_fmt_ana   budget_grp_num  budget_grp_num_r budget_grp_new
       age      age_cat     age_cat_num
       rae_person_new race sex  ;
SET int.analysis2;
RUN;

DATA data.analysis;
/*Drop the vars you're not using in the modeling*/
SET  int.analysis3 (DROP= bh_2016 bh_2017 bh_2018 adj_pd_total_16cat_orig adj_pd_total_17cat_orig 
                    adj_pd_total_18cat_orig budget_grp_fmt_ana budget_grp_num budget_grp_num_r age
                    n_pc_pm n_ed_pm n_ffs_bh_pm n_tel_pm age_cat_num);
RUN; *08-03 15124679:39;

** UPDATE 09-08-2023 ====================================
0. MANUALLY renamed data.analysis = data.analysis_prev
1. Removed int. datasets bc of size issues. 
2. Minimize data.analysis_prev (create data.utilization) by: 
    2a. Minimizing dataset size variables - i.e. budgetgroup doesn't need to be char 22, should be numeric. 
    2b. Binary variables can be length = 3
    2c. mcaid_id length = 7
    2d. Per CS, formats don't add any length etc, so don't need to worry about them. 
;
PROC CONTENTS DATA = data.analysis_prev VARNUM; RUN; 

DATA data.utilization0 (rename=(ind_ed_visit     = ind_visit_ed
                                ind_ffs_bh_visit = ind_visit_ffs_bh
                                ind_tel_visit    = ind_visit_tel
                                inc_pc_visit     = ind_visit_pc
                                ind_total_cost   = ind_cost_total
                                ind_pc_cost      = ind_cost_pc
                                ind_rx_cost      = ind_cost_rx)
                                );
LENGTH time age rae_person_new int int_imp bh_hosp16 bh_hosp17 bh_hosp18 bh_er16 bh_er17 bh_er18 bh_oth16 bh_oth17 bh_oth18 
       adj_pd_total_16cat adj_pd_total_17cat adj_pd_total_18cat ind_pc_visit ind_ed_visit ind_ffs_bh_visit ind_tel_visit
       budget_grp_num_r fyqrtr season1 season2 season3 3.
       mcaid_id 7. 
       sex $1. ;
FORMAT budget_grp_num budget_grp_new_.
SET  data.analysis_prev ;
* assign new numeric values to 3, 5-12 / else 0 (Other);
IF       budget_grp_new = "Other"                  THEN budget_grp_num = 0;
ELSE IF  budget_grp_new = "MAGI 69 - 133% FPL"     THEN budget_grp_num = 1;
ELSE IF  budget_grp_new = "MAGI TO 68% FPL"        THEN budget_grp_num = 2;
ELSE IF  budget_grp_new = "Disabled"               THEN budget_grp_num = 3;
ELSE IF  budget_grp_new = "Foster Care"            THEN budget_grp_num = 4;
ELSE IF  budget_grp_new = "MAGI Eligible Children" THEN budget_grp_num = 5;
ELSE                                                    budget_grp_num = 999;  
RUN; *  15124679 : 34; 






* Reordered so I could see related cols together; 
DATA int.analysis3;
RETAIN mcaid_id time int int_imp season1 season2 season3 
       ind_total_cost     adj_pd_total_tc
       ind_pc_cost        adj_pd_pc_tc
       ind_rx_cost        adj_pd_rx_tc
       ind_pc_visit       n_pc_pm   n_pc_pm_r
       ind_ed_visit       n_ed_pm   n_ed_pm_r
       ind_ffs_bh_visit   n_ffs_bh_pm   n_ffs_bh_pm_r
       ind_tel_visit      n_tel_pm      n_tel_pm_r
       bh_2016  bh_hosp16   bh_er16   bh_oth16
       bh_2017  bh_hosp17   bh_er17   bh_oth17
       bh_2018  bh_hosp18   bh_er18   bh_oth18
       adj_pd_total_16cat_orig  adj_pd_total_16cat
       adj_pd_total_17cat_orig  adj_pd_total_17cat
       adj_pd_total_18cat_orig  adj_pd_total_18cat
       fqhc 
       budget_grp_fmt_ana   budget_grp_num  budget_grp_num_r budget_grp_new
       age      age_cat     age_cat_num
       rae_person_new race sex  ;
SET int.analysis2;
RUN;

DATA data.analysis;
/*Drop the vars you're not using in the modeling*/
SET  int.analysis3 (DROP= bh_2016 bh_2017 bh_2018 adj_pd_total_16cat_orig adj_pd_total_17cat_orig 
                    adj_pd_total_18cat_orig budget_grp_fmt_ana budget_grp_num budget_grp_num_r age
                    n_pc_pm n_ed_pm n_ffs_bh_pm n_tel_pm age_cat_num);
RUN; *08-03 15124679:39;


* create data.analysis_meta ; 
PROC SQL; 
CREATE TABLE data.analysis_meta AS 
SELECT name as variable
     , type
     , length
     , label
     , format
     , informat
FROM sashelp.vcolumn
WHERE LIBNAME = 'DATA' 
AND   MEMNAME = 'ANALYSIS';
quit;

* 
DATA.MINI_DS ==============================================================================
VERSION 08-24
Reduced, testing dataset of 500k records from data.analysis with same int proportion
Step 1: ds has to be sorted on grouping var
Step 2: specify nrow, allocation, and strata
Step 3: Check frequency to test
===========================================================================================;
* Step 1;
proc sort data = data.analysis;
by int ;
run;

* Step 2;
PROC SURVEYSELECT 
DATA = data.analysis
n    = 500000
OUT  = data.mini;
STRATA int / alloc=prop;
RUN;

* Step 3; 
PROC FREQ DATA = data.mini;
tables int; 
run;
* int=0 pct 87.48%
  int=1 pct 12.52% (100-87.48%); 


